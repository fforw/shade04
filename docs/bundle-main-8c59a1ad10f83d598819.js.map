{"version":3,"sources":["webpack://Demo/webpack/bootstrap","webpack://Demo/./node_modules/performance-now/lib/performance-now.js","webpack://Demo/./node_modules/process/browser.js","webpack://Demo/./src/Color.js","webpack://Demo/./src/index.js","webpack://Demo/./src/shade04.vert","webpack://Demo/./src/shade04.frag"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getNanoSeconds","hrtime","loadTime","moduleLoadTime","nodeLoadTime","upTime","performance","now","process","hr","uptime","Date","getTime","this","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","colorRegExp","hex","toString","hue2rgb","q","canvas","gl","vao","program","github","u_time","u_resolution","u_mouse","u_palette","u_shiny","mouseDown","startX","startY","canvasBounds","Color","g","b","color","exec","col","parseInt","substring","factor","isArray","Float32Array","f","from","validate","h","Math","round","other","ratio","out","config","sqrt","PI","width","height","capturer","mouseX","mouseY","captureFrameCount","resize","window","innerWidth","innerHeight","viewport","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","main","time","innerHTML","stop","save","uniform1f","uniform2f","uniform4f","clearColor","clear","COLOR_BUFFER_BIT","primitiveType","TRIANGLES","drawArrays","requestAnimationFrame","capture","onMouseMove","ev","clientX","left","self","pageXOffset","clientY","top","pageYOffset","onMouseDown","onMouseUp","onload","document","getElementById","getContext","parentNode","removeChild","msg","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","positionAttributeLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createVertexArray","bindVertexArray","enableVertexAttribArray","FLOAT","vertexAttribPointer","getUniformLocation","useProgram","addEventListener","getBoundingClientRect","paletteArray","uniform3fv","uniform1fv","querySelector","start"],"mappings":"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","file":"bundle-main-8c59a1ad10f83d598819.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const colorRegExp = /^(#)?([0-9a-f]+)$/i;\n\nfunction hex(n)\n{\n    const s = n.toString(16);\n\n    return s.length === 1 ? \"0\" + s : s;\n}\n\nfunction hue2rgb(p, q, t){\n    if(t < 0) t += 1;\n    if(t > 1) t -= 1;\n    if(t < 1/6) return p + (q - p) * 6 * t;\n    if(t < 1/2) return q;\n    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n    return p;\n}\n\nexport default class Color\n{\n    r;\n    g;\n    b;\n\n    constructor(r,g,b)\n    {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n\n    mix(other, ratio, out)\n    {\n        if (!out)\n        {\n            out = new Color();\n        }\n        out.r = (this.r + (other.r - this.r) * ratio)|0;\n        out.g = (this.g + (other.g - this.g) * ratio)|0;\n        out.b = (this.b + (other.b - this.b) * ratio)|0;\n\n        return out;\n    }\n\n    multiply(n, out)\n    {\n        if (!out)\n        {\n            out = new Color();\n        }\n\n        out.r = this.r * n;\n        out.g = this.g * n;\n        out.b = this.b * n;\n        return out;\n    }\n\n    toRGBHex()\n    {\n        return \"#\" + hex(this.r) + hex(this.g) + hex(this.b );\n    }\n\n    toHex()\n    {\n        return (this.r << 16) + (this.g << 8) + this.b;\n    }\n\n    static validate(color)\n    {\n\n        let m;\n        if (typeof color !== \"string\" || !(m = colorRegExp.exec(color)))\n        {\n            return null;\n        }\n        const col = m[2];\n\n        if (col.length === 3)\n        {\n            return new Color(\n                parseInt(col[0], 16) * 17,\n                parseInt(col[1], 16) * 17,\n                parseInt(col[2], 16) * 17\n            )\n        }\n        else if (col.length === 6)\n        {\n            return new Color(\n                parseInt(col.substring(0, 2), 16),\n                parseInt(col.substring(2, 4), 16),\n                parseInt(col.substring(4, 6), 16)\n            )\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    static from(color, factor = 1.0)\n    {\n        if (Array.isArray(color))\n        {\n            const length = color.length;\n            const array = new Float32Array(length * 3);\n\n            const f = factor/255;\n\n            let off = 0;\n            for (let i = 0; i < length; i++)\n            {\n                const col = Color.from(color[i]);\n                array[off++] = col.r * f;\n                array[off++] = col.g * f;\n                array[off++] = col.b * f;\n            }\n\n            return array;\n        }\n\n        const col = Color.validate(color);\n\n        if (!col)\n        {\n            throw new Error(\"Invalid color \" + color);\n        }\n\n        col.r *= factor;\n        col.g *= factor;\n        col.b *= factor;\n\n        return col;\n    }\n\n    static fromHSL(h,s,l)\n    {\n        let r, g, b;\n\n        if(s <= 0){\n            r = g = b = l; // achromatic\n        }else{\n\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n            r = hue2rgb(p, q, h + 1/3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1/3);\n        }\n\n        return new Color(\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255)\n        );\n    }\n}\n\n","// noinspection ES6UnusedImports\nimport STYLE from \"./style.css\"\nimport perfNow from \"performance-now\"\n\nimport vertexShaderSource from \"./shade04.vert\"\nimport fragmentShaderSource from \"./shade04.frag\"\nimport Color from \"./Color\";\n\n//console.log(fragmentShaderSource)\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst TAU = Math.PI * 2;\nconst DEG2RAD_FACTOR = TAU / 360;\n\nconst config = {\n    width: 0,\n    height: 0\n};\n\nlet canvas, gl, vao, program, github;\n\n\nconst CAPTURE = 0;\nconst CAPTURE_FRAMES = 60 * 20;\n\nconst capturer = CAPTURE ?  new CCapture( { format: 'webm', frameRate: 60, name: \"schalke04-shader\", quality: 85 } ) : null;\n\n// uniform: current time\nlet u_time;\n\nlet u_resolution;\n\nlet u_mouse;\n\nlet u_palette;\n\nlet u_shiny;\n\nlet mouseX = 0, mouseY = 0, mouseDown, startX, startY;\n\nlet captureFrameCount = 0;\n\n// Get the container element's bounding box\nlet canvasBounds;\n\nfunction resize()\n{\n    const width = (window.innerWidth) & ~15;\n    const height = (window.innerHeight)  | 0;\n\n    config.width = width;\n    config.height = height;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    mouseX = width/2;   \n    mouseY = height/2;\n\n    gl.viewport(0, 0, canvas.width, canvas.height);\n}\n\nfunction createShader(gl, type, source) {\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n        return shader;\n    }\n\n    console.error(gl.getShaderInfoLog(shader));  // eslint-disable-line\n    gl.deleteShader(shader);\n    return undefined;\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader) {\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n        return program;\n    }\n\n    console.error(gl.getProgramInfoLog(program));  // eslint-disable-line\n    gl.deleteProgram(program);\n    return undefined;\n}\n\n\nfunction printError(msg)\n{\n    document.getElementById(\"out\").innerHTML = \"<p>\" + msg + \"</p>\";\n}\n\n\nfunction main(time)\n{\n    if (capturer)\n    {\n        github.innerHTML = captureFrameCount + \"/\" + CAPTURE_FRAMES;\n\n        if (captureFrameCount++ > CAPTURE_FRAMES)\n        {\n            capturer.stop();\n            capturer.save();\n            return;\n        }\n    }\n\n    //const start = perfNow();\n    const f = mouseDown ? 1 : -1;\n\n    // update uniforms\n    gl.uniform1f(u_time, time / 1000.0);\n    gl.uniform2f(u_resolution, config.width, config.height);\n    gl.uniform4f(u_mouse, mouseX, config.height - mouseY, startX * f, (config.height - startY) * f);\n\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    // draw\n    const primitiveType = gl.TRIANGLES;\n    const offset = 0;\n    let count = 6;\n    gl.drawArrays(primitiveType, offset, count);\n\n    requestAnimationFrame(main);\n\n    if (capturer)\n    {\n        capturer.capture(canvas);\n    }\n\n}\n\n\nwindow.onload = () => {\n    // Get A WebGL context\n    canvas = document.getElementById(\"screen\");\n    gl = canvas.getContext(\"webgl2\");\n    if (!gl) {\n        canvas.parentNode.removeChild(canvas);\n        printError(\"Cannot run shader. Your browser does not support WebGL2.\");\n        return;\n    }\n\n    // create GLSL shaders, upload the GLSL source, compile the shaders\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    // Link the two shaders into a program\n    program = createProgram(gl, vertexShader, fragmentShader);\n\n    // look up where the vertex data needs to go.\n    const positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n\n    // Create a buffer and put three 2d clip space points in it\n    const positionBuffer = gl.createBuffer();\n\n    // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    const positions = [\n        -1, -1,\n         1, -1,\n        -1, 1,\n        -1, 1,\n         1, 1,\n         1,-1\n    ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n    // Create a vertex array object (attribute state)\n    vao = gl.createVertexArray();\n\n    // and make it the one we're currently working with\n    gl.bindVertexArray(vao);\n\n    // Turn on the attribute\n    gl.enableVertexAttribArray(positionAttributeLocation);\n\n    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    const size = 2;          // 2 components per iteration\n    const type = gl.FLOAT;   // the data is 32bit floats\n    const normalize = false; // don't normalize the data\n    const stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    let offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(\n        positionAttributeLocation, size, type, normalize, stride, offset);\n\n    resize();\n\n    // Tell WebGL how to convert from clip space to pixels\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n\n    u_time = gl.getUniformLocation(program, \"u_time\");\n    u_resolution = gl.getUniformLocation(program, \"u_resolution\");\n    u_mouse = gl.getUniformLocation(program, \"u_mouse\");\n    u_palette = gl.getUniformLocation(program, \"u_palette\");\n    u_shiny = gl.getUniformLocation(program, \"u_shiny\");\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program);\n\n    // Bind the attribute/buffer set we want.\n    gl.bindVertexArray(vao);\n\n    window.addEventListener(\"resize\", resize, true);\n    canvas.addEventListener(\"mousemove\", onMouseMove, true);\n    canvas.addEventListener(\"mousedown\", onMouseDown, true);\n    document.addEventListener(\"mouseup\", onMouseUp, true);\n\n    canvasBounds = document.getElementById(\"screen\").getBoundingClientRect();\n\n    const paletteArray = Color.from(\n        [\n            \"#000\",\n            \"#fff\",\n            \"#c02\",\n            \"#1b1d26\",\n            \"#16181d\",\n            \"#010101\",\n            \"#18120c\",\n            \"#f0f\"\n        ],\n        1/5\n    );\n\n    // paletteArray[3] *= 10;\n    // paletteArray[4] *= 10;\n    // paletteArray[5] *= 10;\n\n    gl.uniform3fv(u_palette, paletteArray);\n    gl.uniform1fv(u_shiny, new Float32Array([\n        2,\n        30,\n        2,\n        2,\n        2,\n        2,\n        2,\n        2\n    ]));\n\n    requestAnimationFrame(main)\n\n    github = document.querySelector(\".github\");\n\n    if (capturer)\n    {\n        capturer.start();\n    }\n}\n\n\n\n// Apply the mouse event listener\n\nfunction onMouseMove(ev)\n{\n    if (mouseDown)\n    {\n        mouseX = (ev.clientX - canvasBounds.left) + self.pageXOffset;\n        mouseY = (ev.clientY - canvasBounds.top) + self.pageYOffset;\n    }\n}\n\nfunction onMouseDown(ev)\n{\n    mouseDown = true;\n    startX = (ev.clientX - canvasBounds.left) + self.pageXOffset;\n    startY = (ev.clientY - canvasBounds.top) + self.pageYOffset;\n    mouseX = startX;\n    mouseY = startY;\n}\n\nfunction onMouseUp(ev)\n{\n    mouseDown = false;\n}\n\n","export default \"#version 300 es\\n#define GLSLIFY 1\\n\\n// an attribute is an input (in) to a vertex shader.\\n// It will receive data from a buffer\\nin vec4 a_position;\\n\\n// all shaders have a main function\\nvoid main() {\\n\\n    // gl_Position is a special variable a vertex shader\\n    // is responsible for setting\\n    gl_Position = a_position;\\n}\\n\";","export default \"#version 300 es\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nuniform float u_time;\\nuniform vec2 u_resolution;\\nuniform vec4 u_mouse;\\nuniform vec3 u_palette[8];\\nuniform float u_shiny[8];\\n\\nconst float pi = 3.141592653589793;\\nconst float tau = pi * 2.0;\\nconst float hpi = pi * 0.5;\\nconst float phi = (1.0+sqrt(5.0))/2.0;\\n\\nout vec4 outColor;\\n\\n#define MAX_STEPS 100\\n#define MAX_DIST 100.\\n#define SURF_DIST .001\\n\\n#define ROT(a) mat2(cos(a), -sin(a), sin(a), cos(a))\\n#define SHEARX(a) mat2(1, 0, sin(a), 1)\\n\\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\\n\\n////////////////////// NOISE\\n\\n//\\tSimplex 3D Noise\\n//\\tby Ian McEwan, Ashima Arts\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\n\\nfloat snoise(vec3 v){\\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n    // First corner\\n    vec3 i  = floor(v + dot(v, C.yyy) );\\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n    // Other corners\\n    vec3 g = step(x0.yzx, x0.xyz);\\n    vec3 l = 1.0 - g;\\n    vec3 i1 = min( g.xyz, l.zxy );\\n    vec3 i2 = max( g.xyz, l.zxy );\\n\\n    //  x0 = x0 - 0. + 0.0 * C\\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\\n\\n    // Permutations\\n    i = mod(i, 289.0 );\\n    vec4 p = permute( permute( permute(\\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n    // Gradients\\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\\n    float n_ = 1.0/7.0; // N=7\\n    vec3  ns = n_ * D.wyz - D.xzx;\\n\\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\\n\\n    vec4 x_ = floor(j * ns.z);\\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n    vec4 x = x_ *ns.x + ns.yyyy;\\n    vec4 y = y_ *ns.x + ns.yyyy;\\n    vec4 h = 1.0 - abs(x) - abs(y);\\n\\n    vec4 b0 = vec4( x.xy, y.xy );\\n    vec4 b1 = vec4( x.zw, y.zw );\\n\\n    vec4 s0 = floor(b0)*2.0 + 1.0;\\n    vec4 s1 = floor(b1)*2.0 + 1.0;\\n    vec4 sh = -step(h, vec4(0.0));\\n\\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n    vec3 p0 = vec3(a0.xy,h.x);\\n    vec3 p1 = vec3(a0.zw,h.y);\\n    vec3 p2 = vec3(a1.xy,h.z);\\n    vec3 p3 = vec3(a1.zw,h.w);\\n\\n    //Normalise gradients\\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n    p0 *= norm.x;\\n    p1 *= norm.y;\\n    p2 *= norm.z;\\n    p3 *= norm.w;\\n\\n    // Mix final noise value\\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n    m = m * m;\\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n    dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\n// Camera helper\\n\\nvec3 Camera(vec2 uv, vec3 p, vec3 l, float z) {\\n    vec3 f = normalize(l-p),\\n    r = normalize(\\n    cross(\\n    vec3(0, 1, 0),\\n    f\\n    )\\n    ),\\n    u = cross(f, r),\\n    c = p + f * z,\\n    i = c + uv.x*r + uv.y*u,\\n    d = normalize(i-p);\\n    return d;\\n}\\n\\n// 2d rotation matrix helper\\nmat2 Rot(float a) {\\n    float x = cos(a);\\n    float y = sin(a);\\n    return mat2(x, -y, y, x);\\n}\\n\\n// RAY MARCHING PRIMITIVES\\n\\nfloat smin(float a, float b, float k) {\\n    float h = clamp(0.5+0.5*(b-a)/k, 0., 1.);\\n    return mix(b, a, h) - k*h*(1.0-h);\\n}\\n\\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\\n    vec3 ab = b-a;\\n    vec3 ap = p-a;\\n\\n    float t = dot(ab, ap) / dot(ab, ab);\\n    t = clamp(t, 0., 1.);\\n\\n    vec3 c = a + t*ab;\\n\\n    return length(p-c)-r;\\n}\\n\\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\\n    vec3 ab = b-a;\\n    vec3 ap = p-a;\\n\\n    float t = dot(ab, ap) / dot(ab, ab);\\n    //t = clamp(t, 0., 1.);\\n\\n    vec3 c = a + t*ab;\\n\\n    float x = length(p-c)-r;\\n    float y = (abs(t-.5)-.5)*length(ab);\\n    float e = length(max(vec2(x, y), 0.));\\n    float i = min(max(x, y), 0.);\\n\\n    return e+i;\\n}\\n\\nfloat sdCappedCylinder( vec3 p, float h, float r )\\n{\\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdSphere(vec3 p, float s)\\n{\\n    return length(p)-s;\\n}\\n\\nfloat sdTorus(vec3 p, vec2 r) {\\n    float x = length(p.xz)-r.x;\\n    return length(vec2(x, p.y))-r.y;\\n}\\n\\nfloat sdRoundBox(vec3 p, vec3 b, float r)\\n{\\n    vec3 q = abs(p) - b;\\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\\n}\\n\\nfloat sdBeam(vec3 p, vec3 c)\\n{\\n    return length(p.xz - c.xy)-c.z;\\n}\\n\\nfloat dBox(vec3 p, vec3 s) {\\n    p = abs(p)-s;\\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\\n}\\n\\nvec2 opUnion(vec2 curr, float d, float id)\\n{\\n//    if (d < curr.x)\\n//    {\\n//        curr.x = d;\\n//        curr.y = id;\\n//    }\\n//\\n//    return curr;\\n\\n    float s = step(curr.x, d);\\n    return s * curr + (1.0 - s) * vec2(d, id);\\n}\\n\\n// Minimum - with corresponding object ID.\\nvec2 objMin(vec2 a, vec2 b){\\n\\n    // Returning the minimum distance along with the ID of the\\n    // object. This is one way to do it. There are others.\\n\\n    // Equivalent to: return a.x < b.x ? a: b;\\n    float s = step(a.x, b.x);\\n    return s*a + (1. - s)*b;\\n}\\n\\nvec2 softMinUnion(vec2 curr, float d, float id)\\n{\\n    if (d < curr.x)\\n    {\\n        curr.x = smin(curr.x, d, 0.5);\\n        curr.y = id;\\n    }\\n\\n    return curr;\\n}\\n\\nfloat sdBoundingBox(vec3 p, vec3 b, float e)\\n{\\n    p = abs(p)-b;\\n    vec3 q = abs(p+e)-e;\\n    return min(min(\\n    length(max(vec3(p.x, q.y, q.z), 0.0))+min(max(p.x, max(q.y, q.z)), 0.0),\\n    length(max(vec3(q.x, p.y, q.z), 0.0))+min(max(q.x, max(p.y, q.z)), 0.0)),\\n    length(max(vec3(q.x, q.y, p.z), 0.0))+min(max(q.x, max(q.y, p.z)), 0.0));\\n}\\n\\nfloat sdHexPrism( vec3 p, vec2 h )\\n{\\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\\n    p = abs(p);\\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\\n    vec2 d = vec2(\\n    length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\\n    p.z-h.y );\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat shape(float v, float x)\\n{\\n    return x > 0.0 ? -abs(v) : abs(v);\\n}\\n\\nconst mat2 frontPlaneRot = ROT(0.05235987755982988);\\nconst mat2 backPlaneRot = ROT(-0.05235987755982988);\\nconst mat2 sCutRot = ROT(0.88);\\nconst mat2 rotate90 = ROT(1.5707963267948966);\\nconst mat2 fourShear = SHEARX(-0.20943951023931953);\\n\\nvec2 getDistance(vec3 p) {\\n\\n    float t = u_time;\\n\\n    // ground plane\\n    //float pd = p.y + 2.0;\\n\\n    vec2 result = vec2(1e6, 0);\\n    float sphere = sdSphere( p , 1.8 );\\n\\n    if (sphere < 0.2)\\n    {\\n        vec3 cutoutPos = p;\\n\\n        cutoutPos.yz *= rotate90;\\n\\n        float cutout = sdCappedCylinder(cutoutPos, 1.89, 1.0);\\n\\n        float gCutout = sdCappedCylinder(cutoutPos, 1.78, 1.0);\\n\\n        float gGapCutout = dBox(cutoutPos - vec3(1.36,0, 0.36), vec3(1,1,0.36));\\n\\n        float gInnerCutout = sdRoundBox(cutoutPos - vec3(-0.2,0,0), vec3(0.42,1,1.12), 0.45);\\n\\n        float flattenedSideCutout = dot(p - vec3(-0.98,0,0), vec3(-1,0,0) );\\n\\n        float gFlapCutout = dBox(cutoutPos - vec3(0.62 + 0.35,0, -0.35), vec3(0.5,1,0.35));\\n\\n        float round = 0.4;\\n\\n        // Letter S\\n\\n        float sCutout = sdRoundBox(cutoutPos - vec3(-0.2,0,0.5), vec3(0.44 - round, 1.0- round, 0.8-round), round);\\n\\n        round = 0.2;\\n\\n        vec3 s2Pos = cutoutPos- vec3( 0.21,0,0.56);\\n\\n        s2Pos.xz *= sCutRot;\\n\\n        float s2Cutout = sdRoundBox(s2Pos , vec3(0.51 - round, 1.1 - round, 0.18-round), round);\\n        sCutout = max(-s2Cutout, sCutout);\\n\\n        s2Pos = cutoutPos- vec3( -0.6,0,0.36);\\n        s2Pos.xz *= sCutRot;\\n\\n        float s3Cutout = sdRoundBox(s2Pos , vec3(0.51 - round, 1.1 - round, 0.18-round), round);\\n        sCutout = max(-s3Cutout, sCutout);\\n\\n        float sSerif = dBox(cutoutPos - vec3(0.2,0, 1.02), vec3(0.05,1,0.24));\\n        sCutout = min(sSerif, sCutout);\\n\\n        sSerif = dBox(cutoutPos - vec3(-0.66,0, 0.03), vec3(0.05,1,0.24));\\n        sCutout = min(sSerif, sCutout);\\n\\n        // Zero\\n\\n        vec3 elongation = vec3(0,1,0.32);\\n\\n        vec3 zCutoutPos = cutoutPos- vec3(-0.47,0,-0.95);\\n\\n        vec3 q = zCutoutPos - clamp( zCutoutPos, -elongation, elongation );\\n\\n        float zeroCutout = sdTorus(q , vec2(0.155, 0.07));\\n\\n        // four\\n\\n        vec3 fourShBoxPos = p;\\n        fourShBoxPos.yx *= fourShear;\\n        float fourShBox = dBox(fourShBoxPos - vec3(.14,-0.8,0), vec3(0.1,0.38,1));\\n\\n        float fourHBox = dBox(p - vec3(.14,-1.08,0), vec3(0.28,0.1,1));\\n\\n        float fourVBox = dBox(p - vec3(.25,-1.15,0), vec3(0.1, 0.3,1));\\n\\n        gInnerCutout = max(flattenedSideCutout, gInnerCutout);\\n        gInnerCutout = max(-gFlapCutout, gInnerCutout);\\n        gInnerCutout = max(-sCutout, gInnerCutout);\\n        gInnerCutout = max(-zeroCutout, gInnerCutout);\\n        gInnerCutout = max(-fourShBox, gInnerCutout);\\n        gInnerCutout = max(-fourHBox, gInnerCutout);\\n        gInnerCutout = max(-fourVBox, gInnerCutout);\\n\\n        gCutout = max(-gGapCutout, gCutout);\\n        gCutout = max(-gInnerCutout, gCutout);\\n        cutout = max(-gCutout, cutout);\\n\\n        vec3 frontPlane = vec3(0,0,-1);\\n        frontPlane.yz *= frontPlaneRot;\\n\\n        vec3 backPlane = vec3(0,0,1);\\n        backPlane.yz *= backPlaneRot;\\n\\n        float front = dot(p + vec3(0,0,.25), frontPlane );\\n        float back = dot(p - vec3(0,0,.25), backPlane)  ;\\n\\n        sphere = max(sphere, front);\\n        sphere = max(sphere, back) - 0.2;\\n        sphere = max(-cutout, sphere);\\n\\n        // DEBUG\\n        //    result = opUnion(result, gFlapCutout, 2.1);\\n        //    result = opUnion(result, gGapCutout, 1.9);\\n        //    result = opUnion(result, sCutout, 2.2);\\n        //    result = opUnion(result, zeroCutout, 2.3);\\n        //    result = opUnion(result, fourShBox, 2.4);\\n        //    result = opUnion(result, fourHBox, 2.5);\\n        //    result = opUnion(result, fourVBox, 2.6);\\n        //    result = opUnion(result, s2Cutout, 2.7);\\n        //    result = opUnion(result, s3Cutout, 2.8);\\n\\n    }\\n\\n    //result = opUnion(result, pd, 4.0);\\n    result = opUnion(result, sphere, 1.0);\\n\\n    vec3 shaftPos = p;\\n\\n    shaftPos.x += (sin((p.z + u_time * 10.0) * 0.23) + sin((p.z + u_time * 10.0) * 0.27)) * 0.55;\\n\\n    shaftPos.yz *= rotate90;\\n    float zOffset = - u_time * 10.0;\\n\\n    float shaft = -sdBeam( shaftPos, vec3(0,0,3) );\\n\\n    float mat = 4.0;\\n\\n    float d = length(vec3(p.x, p.y, 0.0));\\n    vec3 sideShaftPos = p;\\n\\n    if (abs(d) > 1.9)\\n    {\\n        vec3 noisePos = p - vec3(0,0, zOffset);\\n        float n = snoise(noisePos);\\n        float off = shape(n,p.x) * 0.25;\\n        shaft = -sdBeam( shaftPos + off , vec3(0,0,3) ) * 0.6;\\n        mat = n < 0.4 ? 4.0 : 5.0;\\n\\n        sideShaftPos += off * 0.9;\\n\\n        float bottom = dot(p + vec3(0,2.2,0) + off * 0.5, vec3(0,1,0) );\\n\\n        result = opUnion(result, bottom, 3.0);\\n    }\\n\\n    sideShaftPos.z += u_time * 10.0;\\n\\n    sideShaftPos.x += floor(rand(floor(sideShaftPos.z/60.0)) * 4.0) * 10.0 - 10.0;\\n    sideShaftPos.z = mod(sideShaftPos.z - 10. + 0.5 * 60.0, 60.0)- 30.0;\\n\\n    float sideShaft = -dBox( sideShaftPos, vec3(10,3,3) );\\n\\n    shaft = max(shaft, sideShaft);\\n\\n    result = opUnion(result, shaft, mat);\\n\\n    vec3 supportPos = p;\\n    supportPos.x = abs(supportPos.x);\\n    supportPos.x -= 2.5;\\n    supportPos.z -= zOffset;\\n\\n    float c = 20.0;\\n    supportPos.z = mod(supportPos.z+0.5*c,c)-0.5*c;\\n\\n    supportPos.yz *= rotate90;\\n\\n    float support = sdHexPrism(supportPos, vec2(0.4, 2.5)) - 0.05;\\n\\n    vec3 support2Pos = p;\\n\\n    support2Pos.z = mod(supportPos.z+0.5*c,c)-0.5*c;\\n\\n    float support2 = sdHexPrism(support2Pos - vec3(0,2.5,0), vec2(0.4, 20)) - 0.05;\\n\\n    vec3 support3Pos = p;\\n    support3Pos.z -= zOffset;\\n    support3Pos.z = mod(support3Pos.z+0.5*c,c)-0.5*c;\\n    support3Pos.xz *= rotate90;\\n\\n    float support3 = sdHexPrism(support3Pos - vec3(0,2.5,0), vec2(0.4, 20)) - 0.05;\\n\\n    result = opUnion(result, support, 6.0);\\n    result = opUnion(result, support2, 6.0);\\n    result = opUnion(result, support3, 6.0);\\n\\n    return result;\\n}\\n\\nvec2 rayMarch(vec3 ro, vec3 rd) {\\n\\n    float dO = 0.;\\n    float id = 0.0;\\n\\n    for (int i=0; i < MAX_STEPS; i++) {\\n        vec3 p = ro + rd*dO;\\n        vec2 result = getDistance(p);\\n        float dS = result.x;\\n        dO += dS;\\n        id = result.y;\\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST)\\n        break;\\n    }\\n\\n    return vec2(dO, id);\\n}\\n\\nvec3 getNormal(vec3 p) {\\n    float d = getDistance(p).x;\\n    vec2 e = vec2(.001, 0);\\n\\n    vec3 n = d - vec3(\\n        getDistance(p-e.xyy).x,\\n        getDistance(p-e.yxy).x,\\n        getDistance(p-e.yyx).x\\n    );\\n\\n    return normalize(n);\\n}\\n\\nvec3 getPaletteColor(float id)\\n{\\n    int last = u_palette.length() - 1;\\n    //return id < float(last) ? mix(u_palette[int(id)], u_palette[int(id) + 1], fract(id)) : u_palette[last];\\n    return mix(u_palette[int(id)], u_palette[int(id) + 1], fract(id));\\n}\\n\\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\\n    in float distance, // camera to point distance\\n    in vec3  rayOri,   // camera position\\n    in vec3  rayDir,\\n    in vec3 p)  // camera to point vector\\n{\\n    float pos = p.z + u_time * 12.0;\\n\\n    float c = 0.008;\\n    float b = 0.95 + sin((pos + p.x * sin(pos * 0.27)) * 0.31 ) * 0.15 + sin(pos * 0.17 ) * 0.15;\\n\\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\\n    vec3  fogColor  = vec3(0.,0.30196078431372547,0.615686274509804);\\n    return mix( rgb, fogColor, fogAmount );\\n}\\nvoid main(void)\\n{\\n    vec2 uv = (gl_FragCoord.xy-.5*u_resolution.xy)/u_resolution.y;\\n    vec2 m = u_mouse.xy/u_resolution.xy;\\n\\n    vec3 col = vec3(0);\\n    vec3 ro = vec3(\\n    (cos(u_time * 1.7) + cos(u_time * 1.5)) * 0.7,\\n    (sin(u_time * 2.1) - sin(u_time * 1.9)) * 0.5,\\n        -10.0 + sin(u_time) * 2.0\\n    );\\n\\n    //    ro.yz *= Rot((-m.y + 0.5)* 7.0);\\n//    ro.xz *= Rot((-m.x + 0.5)* 7.0 + u_time);\\n\\n    vec3 lookAt = vec3(0);\\n\\n    vec3 rd = Camera(uv, ro, lookAt, 1.3);\\n\\n    vec2 result = rayMarch(ro, rd);\\n\\n    float d = result.x;\\n\\n    vec3 p = ro + rd * d;\\n    if (d < MAX_DIST) {\\n\\n        vec3 lightPos = ro + vec3(0,1,0);\\n        vec3 lightDir = normalize(lightPos - p);\\n        vec3 norm = getNormal(p);\\n\\n        vec3 lightColor = vec3(2.8);\\n\\n        float id = result.y;\\n\\n        // ambient\\n        vec3 ambient = lightColor * vec3(0.001);\\n\\n        // diffuse\\n        float diff = max(dot(norm, lightDir), 0.0);\\n        vec3 tone = getPaletteColor(id);\\n\\n        if (id == 4.0)\\n        {\\n            tone *= snoise(p + vec3(0,0, u_time * 10.0)) * 0.5;\\n        }\\n\\n        vec3 diffuse = lightColor * (diff * tone);\\n\\n        // specular\\n        vec3 viewDir = normalize(ro);\\n        vec3 reflectDir = reflect(-lightDir, norm);\\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_shiny[int(id)]);\\n        vec3 specular = lightColor * spec * vec3(0.7843,0.8823,0.9451) * (id == 1.0 ? 0.24 : 0.1);\\n\\n        col = (ambient + diffuse + specular);\\n\\n    }\\n    col = applyFog(col, d, ro, rd, p);\\n\\n    //col = pow(col, vec3(1.0/2.2));\\n\\n    outColor = vec4(\\n        col,\\n        1.0\\n    );\\n\\n    //outColor = vec4(1,0,1,1);\\n}\\n\";"],"sourceRoot":""}